<div class="container">

    <h1>Overview</h1>

    <h2>Purpose</h2>

    <!-- Additionally, Programmable Video provides the missing pieces required to use WebRTC to build sophisticated applications:
         Global STUN/TURN relays, media services for large-scale group conferences and recording, and signaling infrastructure are all included. -->

    <p>
        <strong>ApiRTC</strong> is built on top <strong>WebRTC</strong>. It helps to fastly build rich media sharing web based applications.
    </p>
    <p><strong>ApiRTC</strong> fills gaps <strong>WebRTC</strong> does not address :</p>
    <ul>
        <li>
            <p><strong>Signalisation</strong> server</p>
            <p>In order to realize a WebRTC application, one must establish a connection between the browsers that want to communicate. WebRTC provides the solution for the media plane but does not implement the signaling, i.e. how one client’s information
                should be sent to remote peers in order to initiate connections.
                <strong>ApiRTC cloud</strong> implements a signaling server using WebSockets. The browser and server interaction is event-based : the browser does not have to poll the server for a reply every time data have to be exchanged.
            </p>
            <p><strong>ApiRTC</strong>&nbsp;<strong>signalisation</strong> enables very fast and interactive communication.</p>

        </li>
        <li>
            <p><strong>STUN/TURN</strong> servers</p>
            <p>To send and receive data to another browser the client must have some specific information. The most important information is the client’s public IP address. Each client or browser must know this information about each other in order to receive
                an incoming connection from another client. Sometimes it’s difficult for the client to know its own public IP address, especially if the client is behind a firewall or NAT, which is very common these days. To overcome this, WebRTC recommends
                the use of a STUN server. A STUN server allows clients to find out their own public IP address and which type of NAT they are behind. Sometimes it can be hard to fetch the information, depending on the NAT, and in that case, a TURN server
                can help the process.</p>
            <p><strong>ApiRTC</strong> provides both STUN and TURN servers.</p>
        </li>
        <li>
            <p><strong>Star topology</strong> infrastructure</p>
            <p>In a common WebRTC application using basic full mesh topology, each client must encode and send their stream(s) to each remote peer in the network : the CPU load and the required uplink bandwidth increases linearly as the number of peers grows.
                This topology is unsuitable for applications where larger groups of peers need to be connected at once.
            </p>
            <p><strong>ApiRTC</strong> enables the usage of a <strong>star topology</strong> by providing SFUs (Selective Forwarding Units) that acts as a central server that relays each peers’ streams.</p>
            <p>MCU (stands for )Multipoint Control Unit) can also be used (TODO: check this ?)</p>
            <p>Providing theses infrastructures, <strong>ApiRTC</strong> enables large scale group conversations support.</p>
        </li>
        <li>
            <p><strong>Administration</strong> infrastructure and services</p>
            <p>dashboard</p>
            <p>recording</p>
        </li>
    </ul>

    <!-- <h2>ApiRTC Terms</h2>

    <ul>
        <li>An <strong>enterprise</strong></li>
        <li>a <strong>user</strong></li>
        <li>the <strong>apiKey</strong></li>
    </ul> -->

    <h2>ApiRTC main and concepts and Classes</h2>

    <ul>
        <li>In a <code>Conversation</code>, individuals can <strong>chat</strong>, <strong>watch</strong>,
            <strong>listen</strong> and/or <strong>share</strong>&nbsp;<strong>real-time audio, video, data,
                screen...</strong>
        </li>
        <li>Usually, each instance of client application instanciates one <code>UserAgent</code> representing the local individual.
        </li>
        <li>A <code>Contact</code> represents a peer individual.</li>
        <li>A <code>Stream</code> is audio, and/or video captured with from sources available from browser.</li>
        <li>A <code>Session</code> must be opened with <strong>ApiRTC</strong>'s servers to create a
            <code>Conversation</code> to which individuals can join.
        </li>
    </ul>

    <h1>Getting Started</h1>

    <h2>Load ApiRTC library</h2>

    <mat-tab-group animationDuration="0ms">
        <mat-tab label="Angular">
            <br>
            <div class="card">
                <div class="card-body">
                    <p>In your angular project run :</p>
                    <p><code>npm install @apizee/apirtc@latest --save</code></p>
                    <p>And in
                        <code>angular.json</code> add script :
                    </p>
                    <pre>
            <code>
            {{ '{' }}
                ...
                "projects": {{ '{' }}
                    "YOUR_PROJECT_NAME": {{ '{' }}
                        ...
                        "architect": {{ '{' }}
                            "build": {{ '{' }}
                                ...
                                "options": {{ '{' }}
                                    ...
                                    "scripts": [
                                        "node_modules/@apizee/apirtc/apiRTC.min.js"
            </code>
                </pre>
                </div>
            </div>
        </mat-tab>
        <mat-tab label="ReactJS">
            <br>
            <div class="card">
                <div class="card-body">
                    <p>TODO</p>
                </div>
            </div>
        </mat-tab>
        <mat-tab label="JS">
            <br>
            <div class="card">
                <div class="card-body">
                    <p>Just add :
                    </p>
                    <p><code>&lt;script type="text/javascript" src="https://cloud.apirtc.com/apiRTC/apiRTC-latest.min.js"&gt;&lt;/script&gt;</code>
                    </p>
                    <!-- <code>&lt;head&gt;...&lt;/head&gt;</code> tags of <code>index.html</code> -->
                    <p>inside <code>&lt;head&gt;...&lt;/head&gt;</code> tag of <code>.html</code> document.</p>
                </div>
            </div>
        </mat-tab>
    </mat-tab-group>
    <br>

    <p class="alert alert-info" role="alert">The <strong>ApiRTC</strong> api reference can be found at <a href="https://dev.apirtc.com/api/reference" target="_blank">https://dev.apirtc.com/api/reference</a></p>

    <h2>UserAgent</h2>

    <p>As the entry point to <strong>ApiRTC</strong>, <code>UserAgent</code> is instanciated using the
        <strong>apiKey</strong> associated to your <strong>enterprise</strong> account on <a href="https://www.apirtc.com" target="_blank">https://www.apirtc.com</a>.
    </p>

    <p class="alert alert-info" role="alert">Get your <strong>apiKey</strong> from <a href="https://cloud.apirtc.com/enterprise/api" target="_blank">https://cloud.apirtc.com/enterprise/api</a>
    </p>

    <p class="text-center"><img src="assets/apirtc_useragent.svg" alt="image"></p>

    <pre class="border"><code>
        userAgent = new apiRTC.UserAgent(&#123;uri: 'apzkey:' + apiKey&#125;);
    </code></pre>
    <!-- 
    <p><code>UserAgent</code> permet d'accèder aux fonctionnalités <strong>non-connectées</strong> d'<strong>ApiRTC</strong>.</p>
    <p>TODO : list non-connected features</p>
    <ul><li></li></ul> -->

    <h2>Stream</h2>

    <p>When <code>UserAgent.createStream</code> is called, a popup opens in the browser to request user acceptance for using media devices. Then it provides an instance of <code>Stream</code>, which carries media
        <strong>stream</strong> from computer device through the browser.
    </p>

    <p>The method <code>Stream.attachToElement</code> binds the <strong>stream</strong> to a DOM
        <code>&lt;video&gt;</code> element in order to display it in the web page.
    </p>

    <p class="text-center"><img src="assets/apirtc_createstream.svg" alt="image"></p>

    <pre class="border"><code>
        userAgent.createStream(&#123;audio: true,video: true&#125;).then(stream => &#123;stream.attachToElement(domElement)&#125;);
    </code></pre>

    <h2>Session</h2>

    <p>To use <strong>ApiRTC</strong>'s connected features, a <code>userAgent</code> must register to get a
        <strong>session</strong>. This can be done with or without authentication.
    </p>
    <!-- <p>TODO: lister les modes d'authentification, ou faire un lien vers un chapitre dédié</p> -->

    <p>Simply using <code>UserAgent.register</code> without authentication details registers a <code>userAgent</code> with
        <strong>ApiRTC</strong>'s servers without authentication.
    </p>

    <p class="text-center"><img src="assets/apirtc_useragent_register.svg" alt="image"></p>

    <pre class="border"><code>
        userAgent.register().then(session => &#123;...&#125;);
    </code></pre>

    <p>The <code>session</code> grants access to connected features such like <strong>conversations</strong> or
        <strong>conferences</strong>.
    </p>

    <h2>Conversation</h2>
    <p>An instance of <code>Conversation</code> is obtained from <code>Session.getOrCreateConversation</code>.
    </p>

    <p class="text-center"><img src="assets/apirtc_session_getOrCreateConversation.svg" alt="image"></p>

    <pre class="border"><code>
        conversation = session.getOrCreateConversation("MY_CONVERSATION");
    </code></pre>

    <!-- note : this is weird : conversation.join()-->
    <!-- could we make something easier to explain in the future : participant.join(conversationId) ? -->
    <p>Calling <code>Conversation.join</code> makes the <code>userAgent</code> used to create the <code>Session</code> used to create this instance of
        <code>Conversation</code> (through it's <code>Session</code>) join the
        <strong>conversation</strong>.
        <!-- The <code>userAgent</code> then becomes a <strong>participant</strong>. -->
    </p>

    <p class="text-center"><img src="assets/apirtc_conversation_join.svg" alt="image"></p>
    <pre class="border"><code>
        conversation.join();
    </code></pre>

    <!-- TODO : this is weird again, now this is the conversation that actually wears the publish method -->
    <p>Once a <strong>conversation</strong> joined, a <code>userAgent</code> can publish a
        <strong>stream</strong> using <code>Conversation.publish</code> method :
    </p>

    <p class="text-center"><img src="assets/apirtc_conversation_publish.svg" alt="image"></p>

    <pre class="border"><code>
        conversation.publish(stream).then(stream => &#123;...&#125;);
    </code></pre>

    <!-- TODO : All that is weird and should be simplified -->
    <p>Subscribing to peer <strong>streams</strong> shall be implemented as followed :</p>
    <ul>
        <li>
            <p>Listen on <code>Conversation</code>&nbsp;<code>'streamListChanged'</code> event to get notified of
                <strong>streams</strong> published to the
                <strong>conversation</strong>. The data provided by the event is a
                <code>StreamInfo</code> : It gives information on <strong>streams</strong> published in the conversation such as the id (<code>StreamInfo.streamId</code>) of the <strong>stream</strong>.
                <code>StreamInfo.listEventType</code> property tells whether the event is triggered for and addition (value
                <code>'added'</code>) or a removal.
            </p>

        </li>
        <li>
            <p>Calling <code>conversation.subscribeToStream</code> with the <code>StreamInfo.streamId</code> of an 'added' remote stream makes this
                <strong>conversation</strong> subscribe to a
                <strong>stream</strong>.
            </p>
        </li>
        <li>
            <p>Finally, listening on <code>Conversation</code>&nbsp;<code>'streamAdded'</code> notifies with a
                <code>Stream</code> instance which can be attached to web page for display.
            </p>
        </li>
    </ul>

    <p class="text-center"><img src="assets/apirtc_conversation_subscribe.svg" alt="image"></p>

    <pre class="border"><code>
        conversation.on('streamListChanged', streamInfo => (&#123;
            if (streamInfo.isRemote === true) &#123;
                if (streamInfo.listEventType === 'added') &#123;
                    conversation.subscribeToStream(streamInfo.streamId);
                    ...
        &#125;);
        conversation.on('streamAdded', stream => (&#123;
            stream.attachToElement(domElement)
        &#125;);
    </code></pre>

    <p>At this stage, the application displays both yours and peers video <strong>streams</strong> in the page !</p>

    <p>This process is important because a <strong>stream</strong> published to a conversation can be restarted for various technical reasons. In this case the
        <code>'streamListChanged'</code> won't be fired ; but the <code>'streamRemoved'</code> event will be fired with corresponding
        <code>Stream</code> instance, and a <code>'streamAdded'</code> with the new instance will follow, allowing to display correct <strong>stream</strong>.
    </p>

    <p>It is then important to listen on <code>'streamRemoved'</code> to undisplay the corresponding <code>Stream</code>.
    </p>

    <p>Handling the remote streamInfo.listEventType === 'removed' is important to get notified that a stream is not published anymore // TODO shal I unsubscribeToStream(streamId) ??

    </p>


    <!-- TODO : provide a simple sample for each framework -->
    <p class="alert alert-info" role="alert">
        Please find full code of examples demonstrating theses concepts on <a href="https://github.com/apizee/ApiRTC-examples" target="_blank">pure JS</a>,
        <a href="https://github.com/kmoyse-apizee/ApiRTC-ng-demo" target="_blank">Angular</a>, <a>React</a>.
    </p>



    <!-- TODO IDEA : -->
    <!-- Faire une documentation v5 qui correspondrait à ce que cela pourrait etre pour etre plus simple
    UserAgent -> Participant
    Session n'existe plus
    On crée une Conversation depuis un autre point d'entrée ?
    les events de converation sont revus pour ne pas avoir streamListChanged puis streamAdded, on aurait plutot participantJoined et sur participant récupéré streamAdded -->


    <!-- 
    <h3>Conference</h3>
    <p>La conférence est une conversation avec la possibilité d'avoir un modérateur qui doit être un utilisateur géré par ApiRTC.</p> -->


</div>